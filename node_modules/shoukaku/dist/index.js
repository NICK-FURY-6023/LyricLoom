"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// index.ts
var Shoukaku_exports = {};
__export(Shoukaku_exports, {
  AllowedPackets: () => AllowedPackets,
  Connection: () => Connection,
  Connector: () => Connector,
  Connectors: () => libs_exports,
  Constants: () => Constants_exports,
  LoadType: () => LoadType,
  Node: () => Node,
  Player: () => Player,
  PlayerEventType: () => PlayerEventType,
  Rest: () => Rest,
  RestError: () => RestError,
  Shoukaku: () => Shoukaku,
  Utils: () => Utils_exports
});
module.exports = __toCommonJS(Shoukaku_exports);

// src/connectors/libs/index.ts
var libs_exports = {};
__export(libs_exports, {
  DiscordJS: () => DiscordJS,
  Eris: () => Eris,
  OceanicJS: () => OceanicJS,
  Seyfert: () => Seyfert
});

// src/Constants.ts
var Constants_exports = {};
__export(Constants_exports, {
  NodeDefaults: () => NodeDefaults,
  OpCodes: () => OpCodes,
  ShoukakuClientInfo: () => ShoukakuClientInfo,
  ShoukakuDefaults: () => ShoukakuDefaults,
  State: () => State,
  Versions: () => Versions,
  VoiceState: () => VoiceState
});

// package.json
var package_default = {
  name: "shoukaku",
  version: "4.1.1",
  description: "A stable and updated wrapper around Lavalink",
  main: "dist/index.js",
  module: "dist/index.mjs",
  types: "dist/index.d.ts",
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      import: "./dist/index.mjs",
      require: "./dist/index.js"
    }
  },
  scripts: {
    build: "npm run build:ts && npm run build:docs",
    "build:ts": "tsup --config tsup-config.json",
    "build:docs": "typedoc --theme default --readme README.md --out docs/ --entryPointStrategy expand src/.",
    lint: "eslint .",
    prepare: "npm run build:ts"
  },
  keywords: [
    "bot",
    "music",
    "lavalink",
    "api",
    "discord",
    "lavalink.js",
    "discord.js",
    "lavalink-api",
    "weeb-library"
  ],
  engines: {
    node: ">=18.0.0",
    npm: ">=7.0.0"
  },
  author: "Saya",
  license: "MIT",
  repository: {
    type: "git",
    url: "https://github.com/shipgirlproject/Shoukaku.git"
  },
  dependencies: {
    ws: "^8.18.0"
  },
  devDependencies: {
    "@shipgirl/eslint-config": "^0.2.2",
    "@types/node": "^22.2.0",
    "@types/ws": "^8.5.12",
    eslint: "^9.9.0",
    tsup: "^8.2.4",
    typedoc: "^0.26.5",
    typescript: "^5.5.4"
  }
};

// src/Constants.ts
var State = /* @__PURE__ */ ((State2) => {
  State2[State2["CONNECTING"] = 0] = "CONNECTING";
  State2[State2["NEARLY"] = 1] = "NEARLY";
  State2[State2["CONNECTED"] = 2] = "CONNECTED";
  State2[State2["RECONNECTING"] = 3] = "RECONNECTING";
  State2[State2["DISCONNECTING"] = 4] = "DISCONNECTING";
  State2[State2["DISCONNECTED"] = 5] = "DISCONNECTED";
  return State2;
})(State || {});
var VoiceState = /* @__PURE__ */ ((VoiceState2) => {
  VoiceState2[VoiceState2["SESSION_READY"] = 0] = "SESSION_READY";
  VoiceState2[VoiceState2["SESSION_ID_MISSING"] = 1] = "SESSION_ID_MISSING";
  VoiceState2[VoiceState2["SESSION_ENDPOINT_MISSING"] = 2] = "SESSION_ENDPOINT_MISSING";
  VoiceState2[VoiceState2["SESSION_FAILED_UPDATE"] = 3] = "SESSION_FAILED_UPDATE";
  return VoiceState2;
})(VoiceState || {});
var OpCodes = /* @__PURE__ */ ((OpCodes3) => {
  OpCodes3["PLAYER_UPDATE"] = "playerUpdate";
  OpCodes3["STATS"] = "stats";
  OpCodes3["EVENT"] = "event";
  OpCodes3["READY"] = "ready";
  return OpCodes3;
})(OpCodes || {});
var Versions = {
  REST_VERSION: 4,
  WEBSOCKET_VERSION: 4
};
var ShoukakuDefaults = {
  resume: false,
  resumeTimeout: 30,
  resumeByLibrary: false,
  reconnectTries: 3,
  reconnectInterval: 5,
  restTimeout: 60,
  moveOnDisconnect: false,
  userAgent: "Discord Bot/unknown (https://github.com/shipgirlproject/Shoukaku.git)",
  structures: {},
  voiceConnectionTimeout: 15,
  nodeResolver: (nodes) => [...nodes.values()].filter((node) => node.state === 2 /* CONNECTED */).sort((a, b) => a.penalties - b.penalties).shift()
};
var ShoukakuClientInfo = `${package_default.name}/${package_default.version} (${package_default.repository.url})`;
var NodeDefaults = {
  name: "Default",
  url: "",
  auth: "",
  secure: false,
  group: void 0
};

// src/Utils.ts
var Utils_exports = {};
__export(Utils_exports, {
  TypedEventEmitter: () => TypedEventEmitter,
  mergeDefault: () => mergeDefault,
  wait: () => wait
});
var import_events = require("events");
var TypedEventEmitter = class extends import_events.EventEmitter {
  constructor() {
    super();
  }
  on(eventName, listener) {
    return super.on(eventName, listener);
  }
  once(eventName, listener) {
    return super.once(eventName, listener);
  }
  off(eventName, listener) {
    return super.off(eventName, listener);
  }
  emit(eventName, ...args) {
    return super.emit(eventName, ...args);
  }
};
function mergeDefault(def, given) {
  if (!given) return def;
  const defaultKeys = Object.keys(def);
  for (const key in given) {
    if (defaultKeys.includes(key)) continue;
    delete given[key];
  }
  for (const key of defaultKeys) {
    if (def[key] === null || typeof def[key] === "string" && def[key].length === 0) {
      if (!given[key]) throw new Error(`${String(key)} was not found from the given options.`);
    }
    if (given[key] === null || given[key] === void 0) given[key] = def[key];
  }
  return given;
}
function wait(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// src/connectors/Connector.ts
var AllowedPackets = ["VOICE_STATE_UPDATE", "VOICE_SERVER_UPDATE"];
var Connector = class {
  constructor(client) {
    this.client = client;
    this.manager = null;
  }
  set(manager) {
    this.manager = manager;
    return this;
  }
  ready(nodes) {
    this.manager.id = this.getId();
    for (const node of nodes) this.manager.addNode(mergeDefault(NodeDefaults, node));
  }
  raw(packet) {
    if (!AllowedPackets.includes(packet.t)) return;
    const guildId = packet.d.guild_id;
    const connection = this.manager.connections.get(guildId);
    if (!connection) return;
    if (packet.t === "VOICE_SERVER_UPDATE") return connection.setServerUpdate(packet.d);
    const userId = packet.d.user_id;
    if (userId !== this.manager.id) return;
    connection.setStateUpdate(packet.d);
  }
};

// src/connectors/libs/DiscordJS.ts
var DiscordJS = class extends Connector {
  // sendPacket is where your library send packets to Discord Gateway
  sendPacket(shardId, payload, important) {
    return this.client.ws.shards.get(shardId)?.send(payload, important);
  }
  // getId is a getter where the lib stores the client user (the one logged in as a bot) id
  getId() {
    return this.client.user.id;
  }
  // Listen attaches the event listener to the library you are using
  listen(nodes) {
    this.client.once("ready", () => this.ready(nodes));
    this.client.on("raw", (packet) => this.raw(packet));
  }
};

// src/connectors/libs/Eris.ts
var Eris = class extends Connector {
  // sendPacket is where your library send packets to Discord Gateway
  sendPacket(shardId, payload, important) {
    return this.client.shards.get(shardId)?.sendWS(payload.op, payload.d, important);
  }
  // getId is a getter where the lib stores the client user (the one logged in as a bot) id
  getId() {
    return this.client.user.id;
  }
  // Listen attaches the event listener to the library you are using
  listen(nodes) {
    this.client.once("ready", () => this.ready(nodes));
    this.client.on("rawWS", (packet) => this.raw(packet));
  }
};

// src/connectors/libs/OceanicJS.ts
var OceanicJS = class extends Connector {
  // sendPacket is where your library send packets to Discord Gateway
  sendPacket(shardId, payload, important) {
    return this.client.shards.get(shardId)?.send(payload.op, payload.d, important);
  }
  // getId is a getter where the lib stores the client user (the one logged in as a bot) id
  getId() {
    return this.client.user.id;
  }
  // Listen attaches the event listener to the library you are using
  listen(nodes) {
    this.client.once("ready", () => this.ready(nodes));
    this.client.on("packet", (packet) => this.raw(packet));
  }
};

// src/connectors/libs/Seyfert.ts
var Seyfert = class extends Connector {
  // sendPacket is where your library send packets to Discord Gateway
  sendPacket(shardId, payload, important) {
    return this.client.gateway.send(shardId, payload);
  }
  // getId is a getter where the lib stores the client user (the one logged in as a bot) id
  getId() {
    return this.client.botId;
  }
  // Listen attaches the event listener to the library you are using
  listen(nodes) {
    this.client.events.values.RAW = {
      data: { name: "raw" },
      run: (packet) => {
        if (packet.t === "READY") return this.ready(nodes);
        return this.raw(packet);
      }
    };
  }
};

// src/guild/Connection.ts
var import_events2 = require("events");
var Connection = class extends import_events2.EventEmitter {
  /**
      * @param manager The manager of this connection
      * @param options The options to pass in connection creation
      * @param options.guildId GuildId in which voice channel to connect to is located
      * @param options.shardId ShardId in which the guild exists
      * @param options.channelId ChannelId of voice channel to connect to
      * @param options.deaf Optional boolean value to specify whether to deafen the current bot user
      * @param options.mute Optional boolean value to specify whether to mute the current bot user
      */
  constructor(manager, options) {
    super();
    this.manager = manager;
    this.guildId = options.guildId;
    this.channelId = options.channelId;
    this.shardId = options.shardId;
    this.muted = options.mute ?? false;
    this.deafened = options.deaf ?? false;
    this.lastChannelId = null;
    this.sessionId = null;
    this.region = null;
    this.lastRegion = null;
    this.serverUpdate = null;
    this.state = 5 /* DISCONNECTED */;
  }
  /**
      * Set the deafen status for the current bot user
      * @param deaf Boolean value to indicate whether to deafen or undeafen
      * @defaultValue false
      */
  setDeaf(deaf = false) {
    this.deafened = deaf;
    this.sendVoiceUpdate();
  }
  /**
      * Set the mute status for the current bot user
      * @param mute Boolean value to indicate whether to mute or unmute
      * @defaultValue false
      */
  setMute(mute = false) {
    this.muted = mute;
    this.sendVoiceUpdate();
  }
  /**
      * Disconnect the current bot user from the connected voice channel
      * @internal
      */
  disconnect() {
    if (this.state === 5 /* DISCONNECTED */) return;
    this.channelId = null;
    this.deafened = false;
    this.muted = false;
    this.removeAllListeners();
    this.sendVoiceUpdate();
    this.state = 5 /* DISCONNECTED */;
    this.debug(`[Voice] -> [Node] & [Discord] : Connection Destroyed | Guild: ${this.guildId}`);
  }
  /**
      * Connect the current bot user to a voice channel
      * @internal
      */
  async connect() {
    if (this.state === 0 /* CONNECTING */ || this.state === 2 /* CONNECTED */) return;
    this.state = 0 /* CONNECTING */;
    this.sendVoiceUpdate();
    this.debug(`[Voice] -> [Discord] : Requesting Connection | Guild: ${this.guildId}`);
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), this.manager.options.voiceConnectionTimeout * 1e3);
    try {
      const [status] = await (0, import_events2.once)(this, "connectionUpdate", { signal: controller.signal });
      if (status !== 0 /* SESSION_READY */) {
        switch (status) {
          case 1 /* SESSION_ID_MISSING */:
            throw new Error("The voice connection is not established due to missing session id");
          case 2 /* SESSION_ENDPOINT_MISSING */:
            throw new Error("The voice connection is not established due to missing connection endpoint");
        }
      }
      this.state = 2 /* CONNECTED */;
    } catch (e) {
      const error = e;
      this.debug(`[Voice] </- [Discord] : Request Connection Failed | Guild: ${this.guildId}`);
      if (error.name === "AbortError")
        throw new Error(`The voice connection is not established in ${this.manager.options.voiceConnectionTimeout} seconds`);
      throw error;
    } finally {
      clearTimeout(timeout);
    }
  }
  /**
      * Updates SessionId, ChannelId, Deafen and Mute data of this instance
      * @param options
      * @param options.session_id Id of the current session
      * @param options.channel_id Id of the connected voice channel
      * @param options.self_deaf Boolean that indicates if the current bot user is deafened or not
      * @param options.self_mute Boolean that indicates if the current bot user is muted or not
      * @internal
      */
  setStateUpdate({ session_id, channel_id, self_deaf, self_mute }) {
    this.lastChannelId = this.channelId?.repeat(1) ?? null;
    this.channelId = channel_id ?? null;
    if (this.channelId && this.lastChannelId !== this.channelId) {
      this.debug(`[Voice] <- [Discord] : Channel Moved | Old Channel: ${this.channelId} Guild: ${this.guildId}`);
    }
    if (!this.channelId) {
      this.state = 5 /* DISCONNECTED */;
      this.debug(`[Voice] <- [Discord] : Channel Disconnected | Guild: ${this.guildId}`);
    }
    this.deafened = self_deaf;
    this.muted = self_mute;
    this.sessionId = session_id ?? null;
    this.debug(`[Voice] <- [Discord] : State Update Received | Channel: ${this.channelId} Session ID: ${session_id} Guild: ${this.guildId}`);
  }
  /**
      * Sets the server update data for this connection
      * @internal
      */
  setServerUpdate(data) {
    if (!data.endpoint) {
      this.emit("connectionUpdate", 2 /* SESSION_ENDPOINT_MISSING */);
      return;
    }
    if (!this.sessionId) {
      this.emit("connectionUpdate", 1 /* SESSION_ID_MISSING */);
      return;
    }
    this.lastRegion = this.region?.repeat(1) ?? null;
    this.region = data.endpoint.split(".").shift()?.replace(/[0-9]/g, "") ?? null;
    if (this.region && this.lastRegion !== this.region) {
      this.debug(`[Voice] <- [Discord] : Voice Region Moved | Old Region: ${this.lastRegion} New Region: ${this.region} Guild: ${this.guildId}`);
    }
    this.serverUpdate = data;
    this.emit("connectionUpdate", 0 /* SESSION_READY */);
    this.debug(`[Voice] <- [Discord] : Server Update Received | Server: ${this.region} Guild: ${this.guildId}`);
  }
  /**
      * Send voice data to discord
      * @internal
      */
  sendVoiceUpdate() {
    this.send({ guild_id: this.guildId, channel_id: this.channelId, self_deaf: this.deafened, self_mute: this.muted });
  }
  /**
      * Send data to Discord
      * @param data The data to send
      * @internal
      */
  send(data) {
    this.manager.connector.sendPacket(this.shardId, { op: 4, d: data }, false);
  }
  /**
      * Emits a debug log
      * @internal
      */
  debug(message) {
    this.manager.emit("debug", this.constructor.name, message);
  }
};

// src/guild/Player.ts
var PlayerEventType = /* @__PURE__ */ ((PlayerEventType2) => {
  PlayerEventType2["TRACK_START_EVENT"] = "TrackStartEvent";
  PlayerEventType2["TRACK_END_EVENT"] = "TrackEndEvent";
  PlayerEventType2["TRACK_EXCEPTION_EVENT"] = "TrackExceptionEvent";
  PlayerEventType2["TRACK_STUCK_EVENT"] = "TrackStuckEvent";
  PlayerEventType2["WEBSOCKET_CLOSED_EVENT"] = "WebSocketClosedEvent";
  return PlayerEventType2;
})(PlayerEventType || {});
var Player = class extends TypedEventEmitter {
  constructor(guildId, node) {
    super();
    this.guildId = guildId;
    this.node = node;
    this.track = null;
    this.volume = 100;
    this.paused = false;
    this.position = 0;
    this.ping = 0;
    this.filters = {};
  }
  get data() {
    const connection = this.node.manager.connections.get(this.guildId);
    return {
      guildId: this.guildId,
      playerOptions: {
        track: {
          encoded: this.track
        },
        position: this.position,
        paused: this.paused,
        filters: this.filters,
        voice: {
          token: connection.serverUpdate.token,
          endpoint: connection.serverUpdate.endpoint,
          sessionId: connection.sessionId
        },
        volume: this.volume
      }
    };
  }
  /**
   * Move player to another node
   * @param name Name of node to move to, or the default ideal node
   * @returns true if the player was moved, false if not
   */
  async move(name) {
    const connection = this.node.manager.connections.get(this.guildId);
    const node = this.node.manager.nodes.get(name) ?? this.node.manager.getIdealNode(connection);
    if (!node && ![...this.node.manager.nodes.values()].some((node2) => node2.state === 2 /* CONNECTED */))
      throw new Error("No available nodes to move to");
    if (!node || node.name === this.node.name || node.state !== 2 /* CONNECTED */) return false;
    let lastNode = this.node.manager.nodes.get(this.node.name);
    if (!lastNode || lastNode.state !== 2 /* CONNECTED */)
      lastNode = this.node.manager.getIdealNode(connection);
    await this.destroy();
    try {
      this.node = node;
      await this.resume();
      return true;
    } catch {
      this.node = lastNode;
      await this.resume();
      return false;
    }
  }
  /**
   * Destroys the player in remote lavalink side
   */
  async destroy() {
    await this.node.rest.destroyPlayer(this.guildId);
  }
  /**
   * Play a new track
   */
  playTrack(playerOptions, noReplace = false) {
    return this.update(playerOptions, noReplace);
  }
  /**
   * Stop the currently playing track
   */
  stopTrack() {
    return this.update({ track: { encoded: null }, position: 0 });
  }
  /**
   * Pause or unpause the currently playing track
   * @param paused Boolean value to specify whether to pause or unpause the current bot user
   */
  setPaused(paused = true) {
    return this.update({ paused });
  }
  /**
   * Seek to a specific time in the currently playing track
   * @param position Position to seek to in milliseconds
   */
  seekTo(position) {
    return this.update({ position });
  }
  /**
   * Sets the global volume of the player
   * @param volume Target volume 0-1000
   */
  setGlobalVolume(volume) {
    return this.update({ volume });
  }
  /**
   * Sets the filter volume of the player
   * @param volume Target volume 0.0-5.0
   */
  async setFilterVolume(volume) {
    return this.setFilters({ volume });
  }
  /**
   * Change the equalizer settings applied to the currently playing track
   * @param equalizer An array of objects that conforms to the Bands type that define volumes at different frequencies
   */
  async setEqualizer(equalizer) {
    return this.setFilters({ equalizer });
  }
  /**
   * Change the karaoke settings applied to the currently playing track
   * @param karaoke An object that conforms to the KaraokeSettings type that defines a range of frequencies to mute
   */
  setKaraoke(karaoke) {
    return this.setFilters({ karaoke: karaoke ?? null });
  }
  /**
   * Change the timescale settings applied to the currently playing track
   * @param timescale An object that conforms to the TimescaleSettings type that defines the time signature to play the audio at
   */
  setTimescale(timescale) {
    return this.setFilters({ timescale: timescale ?? null });
  }
  /**
   * Change the tremolo settings applied to the currently playing track
   * @param tremolo An object that conforms to the FreqSettings type that defines an oscillation in volume
   */
  setTremolo(tremolo) {
    return this.setFilters({ tremolo: tremolo ?? null });
  }
  /**
   * Change the vibrato settings applied to the currently playing track
   * @param vibrato An object that conforms to the FreqSettings type that defines an oscillation in pitch
   */
  setVibrato(vibrato) {
    return this.setFilters({ vibrato: vibrato ?? null });
  }
  /**
   * Change the rotation settings applied to the currently playing track
   * @param rotation An object that conforms to the RotationSettings type that defines the frequency of audio rotating round the listener
   */
  setRotation(rotation) {
    return this.setFilters({ rotation: rotation ?? null });
  }
  /**
   * Change the distortion settings applied to the currently playing track
   * @param distortion An object that conforms to DistortionSettings that defines distortions in the audio
   * @returns The current player instance
   */
  setDistortion(distortion) {
    return this.setFilters({ distortion: distortion ?? null });
  }
  /**
   * Change the channel mix settings applied to the currently playing track
   * @param channelMix An object that conforms to ChannelMixSettings that defines how much the left and right channels affect each other (setting all factors to 0.5 causes both channels to get the same audio)
   */
  setChannelMix(channelMix) {
    return this.setFilters({ channelMix: channelMix ?? null });
  }
  /**
   * Change the low pass settings applied to the currently playing track
   * @param lowPass An object that conforms to LowPassSettings that defines the amount of suppression on higher frequencies
   */
  setLowPass(lowPass) {
    return this.setFilters({ lowPass: lowPass ?? null });
  }
  /**
   * Change the all filter settings applied to the currently playing track
   * @param filters An object that conforms to FilterOptions that defines all filters to apply/modify
   */
  setFilters(filters) {
    return this.update({ filters });
  }
  /**
   * Clear all filters applied to the currently playing track
   */
  clearFilters() {
    return this.setFilters({
      volume: 1,
      equalizer: [],
      karaoke: null,
      timescale: null,
      tremolo: null,
      vibrato: null,
      rotation: null,
      distortion: null,
      channelMix: null,
      lowPass: null
    });
  }
  /**
   * Resumes the current track
   * @param options An object that conforms to ResumeOptions that specify behavior on resuming
   * @param noReplace Set it to true if you don't want to replace the currently playing track
   */
  async resume(options = {}, noReplace = false) {
    const data = this.data;
    if (typeof options.position === "number")
      data.playerOptions.position = options.position;
    if (typeof options.endTime === "number")
      data.playerOptions.endTime = options.endTime;
    if (typeof options.paused === "boolean")
      data.playerOptions.paused = options.paused;
    if (typeof options.volume === "number")
      data.playerOptions.volume = options.volume;
    await this.update(data.playerOptions, noReplace);
    this.emit("resumed", this);
  }
  /**
   * If you want to update the whole player yourself, sends raw update player info to lavalink
   * @param playerOptions Options to update the player data
   * @param noReplace Set it to true if you don't want to replace the currently playing track
   */
  async update(playerOptions, noReplace = false) {
    const data = {
      guildId: this.guildId,
      noReplace,
      playerOptions
    };
    await this.node.rest.updatePlayer(data);
    if (!noReplace) this.paused = false;
    if (playerOptions.filters) {
      this.filters = { ...this.filters, ...playerOptions.filters };
    }
    if (typeof playerOptions.track !== "undefined")
      this.track = playerOptions.track.encoded ?? null;
    if (typeof playerOptions.paused === "boolean")
      this.paused = playerOptions.paused;
    if (typeof playerOptions.volume === "number")
      this.volume = playerOptions.volume;
    if (typeof playerOptions.position === "number")
      this.position = playerOptions.position;
  }
  /**
   * Cleans this player instance
   * @internal
   */
  clean() {
    this.removeAllListeners();
    this.track = null;
    this.volume = 100;
    this.position = 0;
    this.filters = {};
  }
  /**
   * Sends server update to lavalink
   * @internal
   */
  async sendServerUpdate(connection) {
    const playerUpdate = {
      guildId: this.guildId,
      playerOptions: {
        voice: {
          token: connection.serverUpdate.token,
          endpoint: connection.serverUpdate.endpoint,
          sessionId: connection.sessionId
        }
      }
    };
    await this.node.rest.updatePlayer(playerUpdate);
  }
  /**
   * Handle player update data
   */
  onPlayerUpdate(json) {
    const { position, ping } = json.state;
    this.position = position;
    this.ping = ping;
    this.emit("update", json);
  }
  /**
   * Handle player events received from Lavalink
   * @param json JSON data from Lavalink
   * @internal
   */
  onPlayerEvent(json) {
    switch (json.type) {
      case "TrackStartEvent" /* TRACK_START_EVENT */:
        if (this.track) this.track = json.track.encoded;
        this.emit("start", json);
        break;
      case "TrackEndEvent" /* TRACK_END_EVENT */:
        this.emit("end", json);
        break;
      case "TrackStuckEvent" /* TRACK_STUCK_EVENT */:
        this.emit("stuck", json);
        break;
      case "TrackExceptionEvent" /* TRACK_EXCEPTION_EVENT */:
        this.emit("exception", json);
        break;
      case "WebSocketClosedEvent" /* WEBSOCKET_CLOSED_EVENT */:
        this.emit("closed", json);
        break;
      default:
        this.node.manager.emit(
          "debug",
          this.node.name,
          `[Player] -> [Node] : Unknown Player Event Type, Data => ${JSON.stringify(json)}`
        );
    }
  }
};

// src/node/Rest.ts
var LoadType = /* @__PURE__ */ ((LoadType2) => {
  LoadType2["TRACK"] = "track";
  LoadType2["PLAYLIST"] = "playlist";
  LoadType2["SEARCH"] = "search";
  LoadType2["EMPTY"] = "empty";
  LoadType2["ERROR"] = "error";
  return LoadType2;
})(LoadType || {});
var Rest = class {
  /**
      * @param node An instance of Node
      * @param options The options to initialize this rest class
      * @param options.name Name of this node
      * @param options.url URL of Lavalink
      * @param options.auth Credentials to access Lavalnk
      * @param options.secure Weather to use secure protocols or not
      * @param options.group Group of this node
      */
  constructor(node, options) {
    this.node = node;
    this.url = `${options.secure ? "https" : "http"}://${options.url}/v${Versions.REST_VERSION}`;
    this.auth = options.auth;
  }
  get sessionId() {
    return this.node.sessionId;
  }
  /**
      * Resolve a track
      * @param identifier Track ID
      * @returns A promise that resolves to a Lavalink response
      */
  resolve(identifier) {
    const options = {
      endpoint: "/loadtracks",
      options: { params: { identifier } }
    };
    return this.fetch(options);
  }
  /**
      * Decode a track
      * @param track Encoded track
      * @returns Promise that resolves to a track
      */
  decode(track) {
    const options = {
      endpoint: "/decodetrack",
      options: { params: { track } }
    };
    return this.fetch(options);
  }
  /**
      * Gets all the player with the specified sessionId
      * @returns Promise that resolves to an array of Lavalink players
      */
  async getPlayers() {
    const options = {
      endpoint: `/sessions/${this.sessionId}/players`,
      options: {}
    };
    return await this.fetch(options) ?? [];
  }
  /**
      * Gets the player with the specified guildId
      * @returns Promise that resolves to a Lavalink player
      */
  getPlayer(guildId) {
    const options = {
      endpoint: `/sessions/${this.sessionId}/players/${guildId}`,
      options: {}
    };
    return this.fetch(options);
  }
  /**
      * Updates a Lavalink player
      * @param data SessionId from Discord
      * @returns Promise that resolves to a Lavalink player
      */
  updatePlayer(data) {
    const options = {
      endpoint: `/sessions/${this.sessionId}/players/${data.guildId}`,
      options: {
        method: "PATCH",
        params: { noReplace: data.noReplace?.toString() ?? "false" },
        headers: { "Content-Type": "application/json" },
        body: data.playerOptions
      }
    };
    return this.fetch(options);
  }
  /**
      * Deletes a Lavalink player
      * @param guildId guildId where this player is
      */
  async destroyPlayer(guildId) {
    const options = {
      endpoint: `/sessions/${this.sessionId}/players/${guildId}`,
      options: { method: "DELETE" }
    };
    await this.fetch(options);
  }
  /**
      * Updates the session with a resume boolean and timeout
      * @param resuming Whether resuming is enabled for this session or not
      * @param timeout Timeout to wait for resuming
      * @returns Promise that resolves to a Lavalink player
      */
  updateSession(resuming, timeout) {
    const options = {
      endpoint: `/sessions/${this.sessionId}`,
      options: {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: { resuming, timeout }
      }
    };
    return this.fetch(options);
  }
  /**
      * Gets the status of this node
      * @returns Promise that resolves to a node stats response
      */
  stats() {
    const options = {
      endpoint: "/stats",
      options: {}
    };
    return this.fetch(options);
  }
  /**
      * Get routeplanner status from Lavalink
      * @returns Promise that resolves to a routeplanner response
      */
  getRoutePlannerStatus() {
    const options = {
      endpoint: "/routeplanner/status",
      options: {}
    };
    return this.fetch(options);
  }
  /**
      * Release blacklisted IP address into pool of IPs
      * @param address IP address
      */
  async unmarkFailedAddress(address) {
    const options = {
      endpoint: "/routeplanner/free/address",
      options: {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: { address }
      }
    };
    await this.fetch(options);
  }
  /**
      * Get Lavalink info
      */
  getLavalinkInfo() {
    const options = {
      endpoint: "/info",
      options: {
        headers: { "Content-Type": "application/json" }
      }
    };
    return this.fetch(options);
  }
  /**
      * Make a request to Lavalink
      * @param fetchOptions.endpoint Lavalink endpoint
      * @param fetchOptions.options Options passed to fetch
      * @throws `RestError` when encountering a Lavalink error response
      * @internal
      */
  async fetch(fetchOptions) {
    const { endpoint, options } = fetchOptions;
    let headers = {
      "Authorization": this.auth,
      "User-Agent": this.node.manager.options.userAgent
    };
    if (options.headers) headers = { ...headers, ...options.headers };
    const url = new URL(`${this.url}${endpoint}`);
    if (options.params) url.search = new URLSearchParams(options.params).toString();
    const abortController = new AbortController();
    const timeout = setTimeout(() => abortController.abort(), this.node.manager.options.restTimeout * 1e3);
    const method = options.method?.toUpperCase() ?? "GET";
    const finalFetchOptions = {
      method,
      headers,
      signal: abortController.signal
    };
    if (!["GET", "HEAD"].includes(method) && options.body)
      finalFetchOptions.body = JSON.stringify(options.body);
    const request = await fetch(url.toString(), finalFetchOptions).finally(() => clearTimeout(timeout));
    if (!request.ok) {
      const response = await request.json().catch(() => null);
      throw new RestError(response ?? {
        timestamp: Date.now(),
        status: request.status,
        error: "Unknown Error",
        message: "Unexpected error response from Lavalink server",
        path: endpoint
      });
    }
    try {
      return await request.json();
    } catch {
      return;
    }
  }
};
var RestError = class extends Error {
  constructor({ timestamp, status, error, trace, message, path }) {
    super(`Rest request failed with response code: ${status}${message ? ` | message: ${message}` : ""}`);
    this.name = "RestError";
    this.timestamp = timestamp;
    this.status = status;
    this.error = error;
    this.trace = trace;
    this.message = message;
    this.path = path;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// src/node/Node.ts
var import_ws = __toESM(require("ws"));
var Node = class extends TypedEventEmitter {
  /**
      * @param manager Shoukaku instance
      * @param options Options on creating this node
      * @param options.name Name of this node
      * @param options.url URL of Lavalink
      * @param options.auth Credentials to access Lavalnk
      * @param options.secure Whether to use secure protocols or not
      * @param options.group Group of this node
      */
  constructor(manager, options) {
    super();
    this.manager = manager;
    this.rest = new (this.manager.options.structures.rest ?? Rest)(this, options);
    this.name = options.name;
    this.group = options.group;
    this.auth = options.auth;
    this.url = `${options.secure ? "wss" : "ws"}://${options.url}/v${Versions.WEBSOCKET_VERSION}/websocket`;
    this.reconnects = 0;
    this.state = 5 /* DISCONNECTED */;
    this.stats = null;
    this.info = null;
    this.ws = null;
    this.sessionId = null;
    this.initialized = false;
    this.destroyed = false;
  }
  /**
      * Penalties for load balancing
      * @returns Penalty score
      * @internal @readonly
      */
  get penalties() {
    let penalties = 0;
    if (!this.stats) return penalties;
    penalties += this.stats.players;
    penalties += Math.round(Math.pow(1.05, 100 * this.stats.cpu.systemLoad) * 10 - 10);
    if (this.stats.frameStats) {
      penalties += this.stats.frameStats.deficit;
      penalties += this.stats.frameStats.nulled * 2;
    }
    return penalties;
  }
  /**
      * If we should clean this node
      * @internal @readonly
      */
  get shouldClean() {
    return this.destroyed || this.reconnects >= this.manager.options.reconnectTries;
  }
  /**
      * Connect to Lavalink
      */
  connect() {
    if (!this.manager.id) throw new Error("Don't connect a node when the library is not yet ready");
    if (this.destroyed) throw new Error("You can't re-use the same instance of a node once disconnected, please re-add the node again");
    this.state = 0 /* CONNECTING */;
    const headers = {
      "Client-Name": ShoukakuClientInfo,
      "User-Agent": this.manager.options.userAgent,
      "Authorization": this.auth,
      "User-Id": this.manager.id
    };
    if (this.sessionId)
      headers["Session-Id"] = this.sessionId;
    if (!this.initialized)
      this.initialized = true;
    this.emit("debug", `[Socket] -> [${this.name}] : Connecting to ${this.url} ...`);
    const url = new URL(this.url);
    this.ws = new import_ws.default(url.toString(), { headers });
    this.ws.once("upgrade", (response) => this.open(response));
    this.ws.once("close", (...args) => this.close(...args));
    this.ws.on("error", (error) => this.error(error));
    this.ws.on("message", (data) => void this.message(data).catch((error) => this.error(error)));
  }
  /**
      * Disconnect from Lavalink
      * @param code Status code
      * @param reason Reason for disconnect
      */
  disconnect(code, reason) {
    this.destroyed = true;
    this.internalDisconnect(code, reason);
  }
  /**
      * Handle connection open event from Lavalink
      * @param response Response from Lavalink
      * @internal
      */
  open(response) {
    const resumed = response.headers["session-resumed"];
    this.emit("debug", `[Socket] <-> [${this.name}] : Connection Handshake Done! ${this.url} | Resumed Header Value: ${resumed}`);
    this.reconnects = 0;
    this.state = 1 /* NEARLY */;
  }
  /**
      * Handle message from Lavalink
      * @param message JSON message
      * @internal
      */
  async message(message) {
    const json = JSON.parse(message);
    if (!json) return;
    this.emit("raw", json);
    switch (json.op) {
      case "stats" /* STATS */:
        this.emit("debug", `[Socket] <- [${this.name}] : Node Status Update | Server Load: ${this.penalties}`);
        this.stats = json;
        break;
      case "ready" /* READY */: {
        if (!json.sessionId) {
          this.emit("debug", `[Socket] -> [${this.name}] : No session id found from ready op? disconnecting and reconnecting to avoid issues`);
          return this.internalDisconnect(1e3);
        }
        this.sessionId = json.sessionId;
        const players = [...this.manager.players.values()].filter((player) => player.node.name === this.name);
        let resumedByLibrary = false;
        if (!json.resumed && Boolean(this.initialized && (players.length && this.manager.options.resumeByLibrary))) {
          try {
            await this.resumePlayers();
            resumedByLibrary = true;
          } catch (error) {
            this.error(error);
          }
        }
        this.state = 2 /* CONNECTED */;
        this.emit("debug", `[Socket] -> [${this.name}] : Lavalink is ready! | Lavalink resume: ${json.resumed} | Lib resume: ${resumedByLibrary}`);
        this.emit("ready", json.resumed, resumedByLibrary);
        if (this.manager.options.resume) {
          await this.rest.updateSession(this.manager.options.resume, this.manager.options.resumeTimeout);
          this.emit("debug", `[Socket] -> [${this.name}] : Resuming configured!`);
        }
        break;
      }
      case "event" /* EVENT */:
      case "playerUpdate" /* PLAYER_UPDATE */: {
        const player = this.manager.players.get(json.guildId);
        if (!player) return;
        if (json.op === "event" /* EVENT */)
          player.onPlayerEvent(json);
        else
          player.onPlayerUpdate(json);
        break;
      }
      default:
        this.emit("debug", `[Player] -> [Node] : Unknown Message Op, Data => ${JSON.stringify(json)}`);
    }
  }
  /**
      * Handle closed event from lavalink
      * @param code Status close
      * @param reason Reason for connection close
      */
  close(code, reason) {
    this.emit("debug", `[Socket] <-/-> [${this.name}] : Connection Closed, Code: ${code || "Unknown Code"}`);
    this.emit("close", code, String(reason));
    if (this.shouldClean)
      void this.clean();
    else
      void this.reconnect();
  }
  /**
      * To emit error events easily
      * @param error error message
      */
  error(error) {
    this.emit("error", error);
  }
  /**
      * Internal disconnect function
      * @internal
      */
  internalDisconnect(code, reason) {
    if (this.destroyed) return;
    this.state = 4 /* DISCONNECTING */;
    if (this.ws)
      this.ws.close(code, reason);
    else
      void this.clean();
  }
  /**
      * Destroys the websocket connection
      * @internal
      */
  destroy(count = 0) {
    this.ws?.removeAllListeners();
    this.ws?.close();
    this.ws = null;
    this.state = 5 /* DISCONNECTED */;
    if (!this.manager.options.resume) {
      this.sessionId = null;
    }
    if (this.shouldClean) {
      this.destroyed = true;
      this.sessionId = null;
      this.emit("disconnect", count);
    }
  }
  /**
      * Cleans and moves players to other nodes if possible
      * @internal
      */
  async clean() {
    const move = this.manager.options.moveOnDisconnect;
    if (!move) return this.destroy();
    let count = 0;
    try {
      count = await this.movePlayers();
    } catch (error) {
      this.error(error);
    } finally {
      this.destroy(count);
    }
  }
  /**
      * Reconnect to Lavalink
      * @internal
      */
  async reconnect() {
    if (this.state === 3 /* RECONNECTING */) return;
    if (this.state !== 5 /* DISCONNECTED */) this.destroy();
    this.state = 3 /* RECONNECTING */;
    this.reconnects++;
    this.emit("reconnecting", this.manager.options.reconnectTries - this.reconnects, this.manager.options.reconnectInterval);
    this.emit("debug", `[Socket] -> [${this.name}] : Reconnecting in ${this.manager.options.reconnectInterval} seconds. ${this.manager.options.reconnectTries - this.reconnects} tries left`);
    await wait(this.manager.options.reconnectInterval * 1e3);
    this.connect();
  }
  /**
      * Tries to resume the players internally
      * @internal
      */
  async resumePlayers() {
    const playersWithData = [];
    const playersWithoutData = [];
    for (const player of this.manager.players.values()) {
      const serverUpdate = this.manager.connections.get(player.guildId)?.serverUpdate;
      if (serverUpdate)
        playersWithData.push(player);
      else
        playersWithoutData.push(player);
    }
    await Promise.allSettled([
      ...playersWithData.map((player) => player.resume()),
      ...playersWithoutData.map((player) => this.manager.leaveVoiceChannel(player.guildId))
    ]);
  }
  /**
      * Tries to move the players to another node
      * @internal
      */
  async movePlayers() {
    const players = [...this.manager.players.values()];
    const data = await Promise.allSettled(players.map((player) => player.move()));
    return data.filter((results) => results.status === "fulfilled").length;
  }
};

// src/Shoukaku.ts
var Shoukaku = class extends TypedEventEmitter {
  /**
      * @param connector A Discord library connector
      * @param nodes An array that conforms to the NodeOption type that specifies nodes to connect to
      * @param options Options to pass to create this Shoukaku instance
      * @param options.resume Whether to resume a connection on disconnect to Lavalink (Server Side) (Note: DOES NOT RESUME WHEN THE LAVALINK SERVER DIES)
      * @param options.resumeTimeout Time to wait before lavalink starts to destroy the players of the disconnected client
      * @param options.resumeByLibrary Whether to resume the players by doing it in the library side (Client Side) (Note: TRIES TO RESUME REGARDLESS OF WHAT HAPPENED ON A LAVALINK SERVER)
      * @param options.reconnectTries Number of times to try and reconnect to Lavalink before giving up
      * @param options.reconnectInterval Timeout before trying to reconnect
      * @param options.restTimeout Time to wait for a response from the Lavalink REST API before giving up
      * @param options.moveOnDisconnect Whether to move players to a different Lavalink node when a node disconnects
      * @param options.userAgent User Agent to use when making requests to Lavalink
      * @param options.structures Custom structures for shoukaku to use
      * @param options.nodeResolver Used if you have custom lavalink node resolving
      */
  constructor(connector, nodes, options = {}) {
    super();
    this.connector = connector.set(this);
    this.options = mergeDefault(ShoukakuDefaults, options);
    this.nodes = /* @__PURE__ */ new Map();
    this.connections = /* @__PURE__ */ new Map();
    this.players = /* @__PURE__ */ new Map();
    this.id = null;
    this.connector.listen(nodes);
  }
  /**
      * Gets an ideal node based on the nodeResolver you provided
      * @param connection Optional connection class for ideal node selection, if you use it
      * @returns An ideal node for you to do things with
      */
  getIdealNode(connection) {
    return this.options.nodeResolver(this.nodes, connection);
  }
  /**
      * Add a Lavalink node to the pool of available nodes
      * @param options.name Name of this node
      * @param options.url URL of Lavalink
      * @param options.auth Credentials to access Lavalnk
      * @param options.secure Whether to use secure protocols or not
      * @param options.group Group of this node
      */
  addNode(options) {
    const node = new Node(this, options);
    node.on("debug", (...args) => this.emit("debug", node.name, ...args));
    node.on("reconnecting", (...args) => this.emit("reconnecting", node.name, ...args));
    node.on("error", (...args) => this.emit("error", node.name, ...args));
    node.on("close", (...args) => this.emit("close", node.name, ...args));
    node.on("ready", (...args) => this.emit("ready", node.name, ...args));
    node.on("raw", (...args) => this.emit("raw", node.name, ...args));
    node.once("disconnect", (...args) => this.clean(node, ...args));
    node.connect();
    this.nodes.set(node.name, node);
  }
  /**
      * Remove a Lavalink node from the pool of available nodes
      * @param name Name of the node
      * @param reason Reason of removing the node
      */
  removeNode(name, reason = "Remove node executed") {
    const node = this.nodes.get(name);
    if (!node) throw new Error("The node name you specified doesn't exist");
    node.disconnect(1e3, reason);
  }
  /**
      * Joins a voice channel
      * @param options.guildId GuildId in which the ChannelId of the voice channel is located
      * @param options.shardId ShardId to track where this should send on sharded websockets, put 0 if you are unsharded
      * @param options.channelId ChannelId of the voice channel you want to connect to
      * @param options.deaf Optional boolean value to specify whether to deafen or undeafen the current bot user
      * @param options.mute Optional boolean value to specify whether to mute or unmute the current bot user
      * @returns The created player
      */
  async joinVoiceChannel(options) {
    if (this.connections.has(options.guildId))
      throw new Error("This guild already have an existing connection");
    const connection = new Connection(this, options);
    this.connections.set(connection.guildId, connection);
    try {
      await connection.connect();
    } catch (error) {
      this.connections.delete(options.guildId);
      throw error;
    }
    try {
      const node = this.getIdealNode(connection);
      if (!node)
        throw new Error("Can't find any nodes to connect on");
      const player = this.options.structures.player ? new this.options.structures.player(connection.guildId, node) : new Player(connection.guildId, node);
      const onUpdate = (state) => {
        if (state !== 0 /* SESSION_READY */) return;
        void player.sendServerUpdate(connection);
      };
      await player.sendServerUpdate(connection);
      connection.on("connectionUpdate", onUpdate);
      this.players.set(player.guildId, player);
      return player;
    } catch (error) {
      connection.disconnect();
      this.connections.delete(options.guildId);
      throw error;
    }
  }
  /**
      * Leaves a voice channel
      * @param guildId The id of the guild you want to delete
      * @returns The destroyed / disconnected player or undefined if none
      */
  async leaveVoiceChannel(guildId) {
    const connection = this.connections.get(guildId);
    if (connection) {
      connection.disconnect();
      this.connections.delete(guildId);
    }
    const player = this.players.get(guildId);
    if (player) {
      try {
        await player.destroy();
      } catch {
      }
      player.clean();
      this.players.delete(guildId);
    }
  }
  /**
      * Cleans the disconnected lavalink node
      * @param node The node to clean
      * @param args Additional arguments for Shoukaku to emit
      * @returns A Lavalink node or undefined
      * @internal
      */
  clean(node, ...args) {
    node.removeAllListeners();
    this.nodes.delete(node.name);
    this.emit("disconnect", node.name, ...args);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AllowedPackets,
  Connection,
  Connector,
  Connectors,
  Constants,
  LoadType,
  Node,
  Player,
  PlayerEventType,
  Rest,
  RestError,
  Shoukaku,
  Utils
});
//# sourceMappingURL=index.js.map