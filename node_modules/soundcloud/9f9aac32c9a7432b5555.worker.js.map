{"version":3,"sources":["webpack:///9f9aac32c9a7432b5555.worker.js","webpack:///webpack/bootstrap 9f9aac32c9a7432b5555","webpack:///./vendor/recorderjs/recorder.worker.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","global","init","config","sampleRate","numChannels","initBuffers","record","inputBuffer","channel","recBuffers","push","recLength","length","exportWAV","type","buffers","mergeBuffers","interleaved","interleave","dataview","encodeWAV","audioBlob","Blob","this","postMessage","getBuffer","clear","result","Float32Array","offset","i","set","inputL","inputR","index","inputIndex","floatTo16BitPCM","output","input","s","Math","max","min","setInt16","writeString","view","string","setUint8","charCodeAt","samples","buffer","ArrayBuffer","DataView","setUint32","setUint16","onmessage","e","data","command"],"mappings":"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","file":"9f9aac32c9a7432b5555.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {var recLength = 0,\n\t  recBuffers = [],\n\t  sampleRate,\n\t  numChannels;\n\t\n\tglobal.onmessage = function(e){\n\t  switch (e.data.command){\n\t    case 'init':\n\t      init(e.data.config);\n\t      break;\n\t    case 'record':\n\t      record(e.data.buffer);\n\t      break;\n\t    case 'exportWAV':\n\t      exportWAV(e.data.type);\n\t      break;\n\t    case 'getBuffer':\n\t      getBuffer();\n\t      break;\n\t    case 'clear':\n\t      clear();\n\t      break;\n\t  }\n\t};\n\t\n\tfunction init(config){\n\t  sampleRate = config.sampleRate;\n\t  numChannels = config.numChannels;\n\t  initBuffers();\n\t}\n\t\n\tfunction record(inputBuffer){\n\t  for (var channel = 0; channel < numChannels; channel++){\n\t    recBuffers[channel].push(inputBuffer[channel]);\n\t  }\n\t  recLength += inputBuffer[0].length;\n\t}\n\t\n\tfunction exportWAV(type){\n\t  var buffers = [];\n\t  for (var channel = 0; channel < numChannels; channel++){\n\t    buffers.push(mergeBuffers(recBuffers[channel], recLength));\n\t  }\n\t  if (numChannels === 2){\n\t      var interleaved = interleave(buffers[0], buffers[1]);\n\t  } else {\n\t      var interleaved = buffers[0];\n\t  }\n\t  var dataview = encodeWAV(interleaved);\n\t  var audioBlob = new Blob([dataview], { type: type });\n\t\n\t  this.postMessage(audioBlob);\n\t}\n\t\n\tfunction getBuffer(){\n\t  var buffers = [];\n\t  for (var channel = 0; channel < numChannels; channel++){\n\t    buffers.push(mergeBuffers(recBuffers[channel], recLength));\n\t  }\n\t  this.postMessage(buffers);\n\t}\n\t\n\tfunction clear(){\n\t  recLength = 0;\n\t  recBuffers = [];\n\t  initBuffers();\n\t}\n\t\n\tfunction initBuffers(){\n\t  for (var channel = 0; channel < numChannels; channel++){\n\t    recBuffers[channel] = [];\n\t  }\n\t}\n\t\n\tfunction mergeBuffers(recBuffers, recLength){\n\t  var result = new Float32Array(recLength);\n\t  var offset = 0;\n\t  for (var i = 0; i < recBuffers.length; i++){\n\t    result.set(recBuffers[i], offset);\n\t    offset += recBuffers[i].length;\n\t  }\n\t  return result;\n\t}\n\t\n\tfunction interleave(inputL, inputR){\n\t  var length = inputL.length + inputR.length;\n\t  var result = new Float32Array(length);\n\t\n\t  var index = 0,\n\t    inputIndex = 0;\n\t\n\t  while (index < length){\n\t    result[index++] = inputL[inputIndex];\n\t    result[index++] = inputR[inputIndex];\n\t    inputIndex++;\n\t  }\n\t  return result;\n\t}\n\t\n\tfunction floatTo16BitPCM(output, offset, input){\n\t  for (var i = 0; i < input.length; i++, offset+=2){\n\t    var s = Math.max(-1, Math.min(1, input[i]));\n\t    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n\t  }\n\t}\n\t\n\tfunction writeString(view, offset, string){\n\t  for (var i = 0; i < string.length; i++){\n\t    view.setUint8(offset + i, string.charCodeAt(i));\n\t  }\n\t}\n\t\n\tfunction encodeWAV(samples){\n\t  var buffer = new ArrayBuffer(44 + samples.length * 2);\n\t  var view = new DataView(buffer);\n\t\n\t  /* RIFF identifier */\n\t  writeString(view, 0, 'RIFF');\n\t  /* RIFF chunk length */\n\t  view.setUint32(4, 36 + samples.length * 2, true);\n\t  /* RIFF type */\n\t  writeString(view, 8, 'WAVE');\n\t  /* format chunk identifier */\n\t  writeString(view, 12, 'fmt ');\n\t  /* format chunk length */\n\t  view.setUint32(16, 16, true);\n\t  /* sample format (raw) */\n\t  view.setUint16(20, 1, true);\n\t  /* channel count */\n\t  view.setUint16(22, numChannels, true);\n\t  /* sample rate */\n\t  view.setUint32(24, sampleRate, true);\n\t  /* byte rate (sample rate * block align) */\n\t  view.setUint32(28, sampleRate * 4, true);\n\t  /* block align (channel count * bytes per sample) */\n\t  view.setUint16(32, numChannels * 2, true);\n\t  /* bits per sample */\n\t  view.setUint16(34, 16, true);\n\t  /* data chunk identifier */\n\t  writeString(view, 36, 'data');\n\t  /* data chunk length */\n\t  view.setUint32(40, samples.length * 2, true);\n\t\n\t  floatTo16BitPCM(view, 44, samples);\n\t\n\t  return view;\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// 9f9aac32c9a7432b5555.worker.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9f9aac32c9a7432b5555","var recLength = 0,\n  recBuffers = [],\n  sampleRate,\n  numChannels;\n\nglobal.onmessage = function(e){\n  switch (e.data.command){\n    case 'init':\n      init(e.data.config);\n      break;\n    case 'record':\n      record(e.data.buffer);\n      break;\n    case 'exportWAV':\n      exportWAV(e.data.type);\n      break;\n    case 'getBuffer':\n      getBuffer();\n      break;\n    case 'clear':\n      clear();\n      break;\n  }\n};\n\nfunction init(config){\n  sampleRate = config.sampleRate;\n  numChannels = config.numChannels;\n  initBuffers();\n}\n\nfunction record(inputBuffer){\n  for (var channel = 0; channel < numChannels; channel++){\n    recBuffers[channel].push(inputBuffer[channel]);\n  }\n  recLength += inputBuffer[0].length;\n}\n\nfunction exportWAV(type){\n  var buffers = [];\n  for (var channel = 0; channel < numChannels; channel++){\n    buffers.push(mergeBuffers(recBuffers[channel], recLength));\n  }\n  if (numChannels === 2){\n      var interleaved = interleave(buffers[0], buffers[1]);\n  } else {\n      var interleaved = buffers[0];\n  }\n  var dataview = encodeWAV(interleaved);\n  var audioBlob = new Blob([dataview], { type: type });\n\n  this.postMessage(audioBlob);\n}\n\nfunction getBuffer(){\n  var buffers = [];\n  for (var channel = 0; channel < numChannels; channel++){\n    buffers.push(mergeBuffers(recBuffers[channel], recLength));\n  }\n  this.postMessage(buffers);\n}\n\nfunction clear(){\n  recLength = 0;\n  recBuffers = [];\n  initBuffers();\n}\n\nfunction initBuffers(){\n  for (var channel = 0; channel < numChannels; channel++){\n    recBuffers[channel] = [];\n  }\n}\n\nfunction mergeBuffers(recBuffers, recLength){\n  var result = new Float32Array(recLength);\n  var offset = 0;\n  for (var i = 0; i < recBuffers.length; i++){\n    result.set(recBuffers[i], offset);\n    offset += recBuffers[i].length;\n  }\n  return result;\n}\n\nfunction interleave(inputL, inputR){\n  var length = inputL.length + inputR.length;\n  var result = new Float32Array(length);\n\n  var index = 0,\n    inputIndex = 0;\n\n  while (index < length){\n    result[index++] = inputL[inputIndex];\n    result[index++] = inputR[inputIndex];\n    inputIndex++;\n  }\n  return result;\n}\n\nfunction floatTo16BitPCM(output, offset, input){\n  for (var i = 0; i < input.length; i++, offset+=2){\n    var s = Math.max(-1, Math.min(1, input[i]));\n    output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);\n  }\n}\n\nfunction writeString(view, offset, string){\n  for (var i = 0; i < string.length; i++){\n    view.setUint8(offset + i, string.charCodeAt(i));\n  }\n}\n\nfunction encodeWAV(samples){\n  var buffer = new ArrayBuffer(44 + samples.length * 2);\n  var view = new DataView(buffer);\n\n  /* RIFF identifier */\n  writeString(view, 0, 'RIFF');\n  /* RIFF chunk length */\n  view.setUint32(4, 36 + samples.length * 2, true);\n  /* RIFF type */\n  writeString(view, 8, 'WAVE');\n  /* format chunk identifier */\n  writeString(view, 12, 'fmt ');\n  /* format chunk length */\n  view.setUint32(16, 16, true);\n  /* sample format (raw) */\n  view.setUint16(20, 1, true);\n  /* channel count */\n  view.setUint16(22, numChannels, true);\n  /* sample rate */\n  view.setUint32(24, sampleRate, true);\n  /* byte rate (sample rate * block align) */\n  view.setUint32(28, sampleRate * 4, true);\n  /* block align (channel count * bytes per sample) */\n  view.setUint16(32, numChannels * 2, true);\n  /* bits per sample */\n  view.setUint16(34, 16, true);\n  /* data chunk identifier */\n  writeString(view, 36, 'data');\n  /* data chunk length */\n  view.setUint32(40, samples.length * 2, true);\n\n  floatTo16BitPCM(view, 44, samples);\n\n  return view;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./vendor/recorderjs/recorder.worker.js\n// module id = 0\n// module chunks = 0"],"sourceRoot":""}