"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KazagumoTrack = void 0;
const Interfaces_1 = require("../../Modules/Interfaces");
class KazagumoTrack {
    constructor(raw, requester) {
        this.raw = raw;
        this.resolvedBySource = false;
        this.kazagumo = undefined;
        this.track = raw.encoded;
        this.sourceName = raw.info.sourceName;
        this.title = raw.info.title;
        this.uri = raw.info.uri;
        this.identifier = raw.info.identifier;
        this.isSeekable = raw.info.isSeekable;
        this.isStream = raw.info.isStream;
        this.author = raw.info.author;
        this.length = raw.info.length;
        this.thumbnail = raw.info.artworkUrl;
        this.realUri = Interfaces_1.SupportedSources.includes(this.sourceName) ? this.uri : undefined;
        this.requester = requester;
        if (this.sourceName === 'youtube' && this.identifier)
            this.thumbnail = `https://img.youtube.com/vi/${this.identifier}/hqdefault.jpg`;
    }
    /**
     * Get json of this track
     * @returns {RawTrack}
     */
    getRaw() {
        return {
            track: this.track,
            info: {
                title: this.title,
                uri: this.uri,
                identifier: this.identifier,
                author: this.author,
                sourceName: this.sourceName,
                isSeekable: this.isSeekable,
                isStream: this.isStream,
                length: this.length,
                position: this.position,
                artworkUrl: this.thumbnail,
            },
            _raw: this.raw,
        };
    }
    /**
     * Set kazagumo instance
     * @param kazagumo Kazagumo instance
     * @returns KazagumoTrack
     */
    setKazagumo(kazagumo) {
        var _a;
        this.kazagumo = kazagumo;
        if (this.sourceName === 'youtube' && this.identifier)
            this.thumbnail = `https://img.youtube.com/vi/${this.identifier}/${(_a = kazagumo.KazagumoOptions.defaultYoutubeThumbnail) !== null && _a !== void 0 ? _a : 'hqdefault'}.jpg`;
        return this;
    }
    /**
     * Whether the track is ready to play or need to be solved
     */
    get readyToPlay() {
        return (this.kazagumo !== undefined &&
            !!this.track &&
            !!this.sourceName &&
            !!this.identifier &&
            !!this.author &&
            !!this.length &&
            !!this.title &&
            !!this.uri &&
            !!this.realUri);
    }
    /**
     * Resolve the track
     * @param options Resolve options
     * @returns Promise<KazagumoTrack>
     */
    resolve(options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.kazagumo)
                throw new Interfaces_1.KazagumoError(1, 'Kazagumo is not set');
            if (this.kazagumo.KazagumoOptions.trackResolver &&
                typeof this.kazagumo.KazagumoOptions.trackResolver === 'function' &&
                (yield this.kazagumo.KazagumoOptions.trackResolver.bind(this)(options)))
                return this;
            const resolveSource = (_b = (_a = this.kazagumo.KazagumoOptions) === null || _a === void 0 ? void 0 : _a.sourceForceResolve) === null || _b === void 0 ? void 0 : _b.includes(this.sourceName);
            const { forceResolve, overwrite } = options ? options : { forceResolve: false, overwrite: false };
            if (!forceResolve && this.readyToPlay)
                return this;
            if (resolveSource && this.resolvedBySource)
                return this;
            if (resolveSource) {
                this.resolvedBySource = true;
                return this;
            }
            this.kazagumo.emit(Interfaces_1.Events.Debug, `Resolving ${this.sourceName} track ${this.title}; Source: ${this.sourceName}`);
            const result = yield this.getTrack((_c = options === null || options === void 0 ? void 0 : options.player) !== null && _c !== void 0 ? _c : null);
            if (!result)
                throw new Interfaces_1.KazagumoError(2, 'No results found');
            this.track = result.encoded;
            this.realUri = result.info.uri;
            this.length = result.info.length;
            if (overwrite || resolveSource) {
                this.title = result.info.title;
                this.identifier = result.info.identifier;
                this.isSeekable = result.info.isSeekable;
                this.author = result.info.author;
                this.length = result.info.length;
                this.isStream = result.info.isStream;
                this.uri = result.info.uri;
            }
            return this;
        });
    }
    getTrack(player) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.kazagumo)
                throw new Error('Kazagumo is not set');
            const defaultSearchEngine = this.kazagumo.KazagumoOptions.defaultSearchEngine;
            const source = (Interfaces_1.SourceIDs[defaultSearchEngine || 'youtube'] || 'yt') + 'search:';
            const query = [this.author, this.title].filter((x) => !!x).join(' - ');
            const node = yield this.kazagumo.getLeastUsedNode();
            if (!node)
                throw new Interfaces_1.KazagumoError(1, 'No nodes available');
            const result = player
                ? yield player.search(query, { source, requester: this.requester })
                : yield this.kazagumo.search(query, { engine: defaultSearchEngine, requester: this.requester });
            if (!result || !result.tracks.length)
                throw new Interfaces_1.KazagumoError(2, 'No results found');
            const rawTracks = result.tracks.map((x) => x.getRaw()._raw);
            if (this.author) {
                const author = [this.author, `${this.author} - Topic`];
                const officialTrack = rawTracks.find((track) => author.some((name) => new RegExp(`^${(0, Interfaces_1.escapeRegExp)(name)}$`, 'i').test(track.info.author)) ||
                    new RegExp(`^${(0, Interfaces_1.escapeRegExp)(this.title)}$`, 'i').test(track.info.title));
                if (officialTrack)
                    return officialTrack;
            }
            if (this.length) {
                const sameDuration = rawTracks.find((track) => track.info.length >= (this.length ? this.length : 0) - 2000 &&
                    track.info.length <= (this.length ? this.length : 0) + 2000);
                if (sameDuration)
                    return sameDuration;
            }
            return rawTracks[0];
        });
    }
}
exports.KazagumoTrack = KazagumoTrack;
