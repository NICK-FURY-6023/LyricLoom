"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.KazagumoQueue = void 0;
const Interfaces_1 = require("../../Modules/Interfaces");
class KazagumoQueue extends Array {
    constructor(kazagumoPlayer) {
        super();
        this.kazagumoPlayer = kazagumoPlayer;
        /** Current playing track */
        this.current = null;
        /** Previous playing tracks */
        this.previous = [];
    }
    /** Get the size of queue */
    get size() {
        return this.length;
    }
    /** Get the size of queue including current */
    get totalSize() {
        return this.length + (this.current ? 1 : 0);
    }
    /** Check if the queue is empty or not */
    get isEmpty() {
        return this.length === 0;
    }
    /** Get the queue's duration */
    get durationLength() {
        return this.reduce((acc, cur) => acc + (cur.length || 0), 0);
    }
    /**
     * Add track(s) to the queue
     * @param track KazagumoTrack to add
     * @returns KazagumoQueue
     */
    add(track) {
        if (!Array.isArray(track))
            track = [track];
        if (!this.current) {
            if (Array.isArray(track))
                this.current = track.shift();
            else {
                this.current = track;
                return this;
            }
        }
        if (Array.isArray(track))
            for (const t of track)
                this.push(t);
        else
            this.push(track);
        this.emitChanges();
        return this;
    }
    /**
     * Remove track from the queue
     * @param position Position of the track
     * @returns KazagumoQueue
     */
    remove(position) {
        if (position < 0 || position >= this.length)
            throw new Interfaces_1.KazagumoError(1, 'Position must be between 0 and ' + (this.length - 1));
        this.splice(position, 1);
        this.emitChanges();
        return this;
    }
    /** Shuffle the queue */
    shuffle() {
        for (let i = this.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this[i], this[j]] = [this[j], this[i]];
        }
        this.emitChanges();
        return this;
    }
    /** Clear the queue */
    clear() {
        this.splice(0, this.length);
        this.emitChanges();
        return this;
    }
    emitChanges() {
        // @ts-ignore
        this.kazagumoPlayer.shoukaku.emit(Interfaces_1.Events.QueueUpdate, this.kazagumoPlayer, this);
    }
}
exports.KazagumoQueue = KazagumoQueue;
